<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="2">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">charSetSolids();

// Climbing down stairs
// if we aren't falling this frame, and we're not on a dropdown platform
if(vspeed == 0 and ((keyState &amp; $02) or !place_meeting(x, y+1, DropdownPlatform) or place_meeting(x, y, DropdownPlatform)))
{ 
    if(place_free(x,y+6))
        if(!place_free(x,y+7))
            y += 6;
        else if(speed &gt; 6) if(place_free(x,y+12)) if(!place_free(x,y+13))
            y += 12;
}
xprevious = x;
yprevious = y;


// dash goes here for collision detection
for(i=0; i&lt;2; i+=1) {
    if (abilityActive[i] and ability[i] == ABILITY_DASH) {
        if(!place_free(x + hspeed, y)) { // we hit a wall on the left or right
            if(place_free(x + sign(hspeed), y - 6)) // if we could just walk up the step
            {
                playsound(x,y,DetoTrimpSnd);
                if (keyState &amp; $80) {
                    vspeed -= 7.5 * accel; // hold W to fly
                }
                //effect_create_below(ef_smoke,x-hspeed*1.2,y-vspeed*1.2+40,0,c_gray);
                if !variable_local_exists("jumpFlameParticleType")
                {
                    jumpFlameParticleType = part_type_create();
                    part_type_sprite(jumpFlameParticleType,FlameS,true,false,true);
                    part_type_alpha2(jumpFlameParticleType,1,0.3);
                    part_type_life(jumpFlameParticleType,2/global.delta_factor,5/global.delta_factor);
                    part_type_scale(jumpFlameParticleType,0.7,-0.65);
                }
                
                if !variable_global_exists("jumpFlameParticleSystem")
                {
                    global.jumpFlameParticleSystem = part_system_create();
                    part_system_depth(global.jumpFlameParticleSystem, 10);
                }
                
                if(global.particles == PARTICLES_NORMAL or global.particles == PARTICLES_ALTERNATIVE)
                {
                    part_particles_create(global.jumpFlameParticleSystem,x,y+19,jumpFlameParticleType,1);
                }
                accel += 0.35;
                //if (!onground) vspeed += 1.5 * (accel * 1.5);
                if (accel &gt;= 6 &amp;&amp; !onground) { 
                    vspeed /= -vspeed * -2;
                }
            } else {
                if (accel &gt;= 5 &amp;&amp; !onground) { // wall bumped and youre flying lets bounce
                    //vspeed += 0.2 * (accel * 5);
                    // I may have gone too far for the funny
                    if (lastTurn != 1) { // left
                        playsound(x,y,DetoSlamSnd);
                        accel *= 2;
                        //if(place_free(x + 4, y)) hspeed += 4;
                        //hspeed *= -hspeed * 12;
                        hspeed = -hspeed * (12 * accel);
                        vspeed -= 4 * accel;
                        dashon = false;
                    } else if (lastTurn != -1) { // right
                        playsound(x,y,DetoSlamSnd);
                        //if(place_free(x - 4, y)) hspeed -= 4;
                        //hspeed /= hspeed * 12;
                        accel *= 2;
                        hspeed = -hspeed * (12 * accel);
                        vspeed -= 4 * accel;
                        dashon = false;
                    } else {
                        //playsound(x,y,PickupSnd);
                        //vspeed /= -vspeed * -0.1;
                    }
                }
                accel = min(0.35, accel - 0.1);
                //if place_free(x, y + 6) vspeed += 10;
                //vspeed = min(vspeed * accel, vspeed + 2.5 * (-accel * 0.45));
            }
        }
            //if (accel &gt;= 2) show_error(string(accel), false); // show me the acceleration!
            if (keyState &amp; $80) {
                if (accel &gt; 1.3 &amp;&amp; !onground) {
                    moveStatus = 4; // bork it so youre always flyin
                if (flight) {
                    playsound(x,y,DetoFlyStartSnd);
                    flight = false;
                }
                } else {
                    flight = true;
                }
            }
    }
}

charUnsetSolids();

if(global.isHost &amp;&amp; hp&lt;=0) {
    var assistant;
    assistant = secondToLastDamageDealer;
    with(lastDamageDealer)
        if (object)
            if (object.healer)
                assistant = object.healer;
                
    sendEventPlayerDeath(player, lastDamageDealer, assistant, lastDamageSource);
    doEventPlayerDeath(player, lastDamageDealer, assistant, lastDamageSource);
    with(GameServer) {
        ServerBalanceTeams();
    }
    exit;
}
    
if(hp&gt;maxHp) {
    hp=maxHp;
}

// overheal from BassMakesPaste
if overhealHp &lt;= 0 {
    overhealed = false;
    overhealHp = 0;
}

if overhealHp &gt; 0 {
//if (global.particles=PARTICLES_NORMAL or global.particles=PARTICLES_ALTERNATIVE){ ignore that, this is vital to HP tracking
if random((30 * overhealMaxHp / overhealHp) / global.delta_factor) &lt; 10 {
    xr= round(x);
    yr= round(y);
    xh= random_range(-30,5);
    yh= random_range(-26,13);
    healie = instance_create(xh+xr,yh+yr,HealingParticle);
    healie.owner = id;
    if (team == TEAM_RED) healie.sprite_index = HealingParticleRedS; else healie.sprite_index = HealingParticleBlueS
    healie.xoffset = xh;
    healie.yoffset = yh;
    healie.depth = choose(2,-2);
    }
}

if (overhealHp&gt;overhealMaxHp) {
    overhealHp=overhealMaxHp;
}

// misc tracking
if (weaponType[activeWeapon] == WTYPE_MINEGUN)
{
    lobbed[activeWeapon] = currentWeapon.lobbed;
}
if (weaponType[activeWeapon] == WTYPE_HEALBEAM)
{
    uberChargeC = currentWeapon.uberCharge;
    uberReadyC = currentWeapon.uberReady;
    /*
    uberCharge[activeWeapon] = currentWeapon.uberCharge;
    uberReady[activeWeapon] = currentWeapon.uberReady;
    */
}

ammo[currentWeapon.activeWeapon] = currentWeapon.ammoCount;

// ability tracking
// todo: move to a networking call, find out after playtesting
/* example
    sendEventAbility(global.serverSocket, ability[activeWeapon]);
    send_ubyte(ABILITY);
    socket_send(global.server);
    doEventAbility(ability[activeWeapon]);
*/
if (ability[activeWeapon] == ABILITY_AMMOGAIN and currentWeapon.maxAmmo != meter[activeWeapon]) currentWeapon.maxAmmo = meter[activeWeapon];
for(i=0; i&lt;2; i+=1) {
    if (abilityActive[i]) {
        /*if (abilityBuffer[i] == ABUFFER_ACTIVE and i != activeWeapon) {
            abilityActive[i] = false;
            break;
        }*/
        switch(ability[i])
        {
            case ABILITY_HEAL:
                with(Character) {
                    if point_distance(other.x,other.y,x,y) &lt; 64
                        if player.team == other.team &amp;&amp; hp &lt; maxHp &amp;&amp; id != other hp = min(maxHp,hp+0.7);
                }
            break;
            case ABILITY_MINICRIT:
                currentWeapon.crit = 1.15;
                if (cancelAbility[i] == ACANCEL_ALARM and tracker.alarm[i] &lt;= 0)
                {
                    tracker.alarm[i] = currentWeapon.reloadTime / global.delta_factor;
                }
            break;
            case ABILITY_CRIT:
                currentWeapon.crit = 1.35;
                if (cancelAbility[i] == ACANCEL_ALARM and tracker.alarm[i] &lt;= 0)
                {
                    tracker.alarm[i] = currentWeapon.reloadTime / global.delta_factor;
                    abilityAlarmPrimed[i] = true;
                }
            break;
            case ABILITY_CHARGEDSHOT:
                if (meter[i] &gt; 0) {
                    runPower = 0.6;
                    jumpStrength = 6;
                    with(currentWeapon) {
                        readyToShoot = false;
                        readyToStab = false;
                        readyToSwing = false;
                        readyToFlare = false;
                        readyToBlast = false;
                    }
                }
                else if (meter[i] &lt;= 0) {
                    abilityActive[i] = false;
                    playsound(x,y,PickupSnd);
                    canSwitch = true;
                    meter[i] = 25;
                    with(currentWeapon) {
                        crit = 1.35;
                        readyToShoot = true;
                        readyToSwing = true;
                        event_user(1);
                        crit = 1;
                        ammoCount = 25;
                    }
                    runPower = baseRunPower;
                    jumpStrength = baseJumpStrength;
                }
            break;
            case ABILITY_INVULN:
                // todo: its very unorganized how there's multiple readyToGun variables, change this in later releases?
                with(currentWeapon) {
                    readyToShoot = false;
                    readyToStab = false;
                    readyToSwing = false;
                    readyToFlare = false;
                    readyToBlast = false;
                }
            break;
        }
        if (meter[i] &lt;= 0 and cancelAbility[i] == ADEPLETE) {
            abilityActive[i] = false;
            if (ability[i] == ABILITY_DASH and currentWeapon.weaponType == WTYPE_MELEE) {
                currentWeapon.crit = 1;
                playsound(x,y,UberEndSnd);
            }
        }
    }
    if (i != activeWeapon and chargeWhileActive[i] || pauseMeter[i]) continue;
    if (meter[i] &gt;= maxMeter[i] and activateAbility[i] == AACTIVATE_MAX) abilityActive[i] = true;
    if (abilityActive[i] and meter[i] &gt; 0) meter[i] -= meterDrain[i] * global.delta_factor;
    
    switch(rechargeAbility[i])
    {
        case ACHARGE_ALARM:
            if (weaponType[i] == WTYPE_CONSUMABLE) {
                if (alarm[6] != -1) meter[i] = alarm[6];
            } else {
                if (meter[i] != maxMeter[i]) meter[i] = tracker.alarm[i];
            }
        break;
        case ACHARGE_AMMO:
            if (!abilityActive) meter[i] = ammo[i];
        break;
        case ACHARGE_RUN:
            if (hspeed != 0 &amp;&amp; onground &amp;&amp; !abilityActive[i]) {
                meter[i] += (rechargeRate[i] / 16 * speed) * global.delta_factor;
            }
        break;
    }
}


if(((aimDirection+270) mod 360)&gt;180) {
    image_xscale=1;
    currentWeapon.image_xscale=1;
    if(currentWeapon.isMelee == true){
    currentWeapon.image_angle = 0;
    }else{
    currentWeapon.image_angle = aimDirection;
}
} else {
    image_xscale=-1;
    currentWeapon.image_xscale=-1;
    if(currentWeapon.isMelee == true){
    currentWeapon.image_angle = 0;
    }else{
    currentWeapon.image_angle = aimDirection+180;
}
}
    
currentWeapon.x=round(x);
currentWeapon.y=round(y);
    
// Limit people to the area of the room to prevent the
// "Falling through the floors" issue.
if(x&lt;0) {
    x=0;
}
if(x&gt;map_width()){
    x = map_width();
}
if(y&lt;0) {
    y = 0;
}
if(y&gt;map_height()){
    y = map_height();
}

    
// Cloak
if (cloak and cloakAlpha &gt; 0 and !cloakFlicker)
    cloakAlpha = max(cloakAlpha - 0.05, 0);
else if (!cloak and cloakAlpha &lt; 1)
    cloakAlpha = min(cloakAlpha + 0.05, 1);
    
// Taunts
if (taunting)
{
    tauntindex += tauntspeed*0.1 * global.delta_factor;
    if (tauntindex &gt;= sprite_get_number(tauntsprite))
        taunting = false;
    if (hasClassReward(player, "TauntMoney_"))
    {
        if (tauntindex == 0.30)
            instance_create(x, y, Money);
    }
}
    
//sandvich
if (omnomnomnom)
{
    omnomnomnomindex += 0.25 * global.delta_factor;
    image_xscale=xscale;
    if(hp &lt; maxHp) // This should prevent the "ate and got hit but didn't refresh cooldown" bug
    { // Also, cooldown is now reset continually until fully healed or finished eating.
        canEat = false;
        alarm[6] = eatCooldown / global.delta_factor;
    }
    if (hp &lt;= maxHp)
        hp += nomRate * global.delta_factor;
    if (hp == maxHp and currentWeapon.object_index == ChocolateHand || global.weapons[weapons[1]] == ChocolateHand)
    {
        overhealed=true;
        overhealHp = min(overhealHp + 0.33 * global.delta_factor, overhealMaxHp);
    }
    if (omnomnomnomindex &gt;= omnomnomnomend)
        omnomnomnom=false;
}

//dripping
if (soaked)
{
    var milk_stacks, piss_stacks, blood_stacks;
    milk_stacks = ds_map_find_value(effects, SOAK_MILK);
    piss_stacks = ds_map_find_value(effects, SOAK_PISS);
    blood_stacks = ds_map_find_value(effects, SOAK_BLOOD);
    if (milk_stacks &gt;= 1) {
        repeat(random(floor(2))) {
            var milk;
            milk = instance_create(x+random(32)-16,y+random(32)-16, BloodDrop);
            milk.sprite_index = MilkS;
        }
    }
    if (piss_stacks &gt;= 1) {
        repeat(random(floor(2))) {
            var piss;
            piss = instance_create(x+random(32)-16,y+random(32)-16, BloodDrop);
            piss.sprite_index = PissS;
        }
    }
    if (blood_stacks &gt;= 1) {
        repeat(random(floor(2))) {
            var blood;
            blood = instance_create(x+random(32)-16,y+random(32)-16, BloodDrop);
        }
        // todo: blood with softcoded check
    }
    
    if ubered or specialUbered or (milk_stacks &lt; 0 and piss_stacks &lt; 0 and blood_stacks &lt; 0) {
        soaked = false;
        ds_map_replace(effects, SOAK_MILK, 0);
        ds_map_replace(effects, SOAK_PISS, 0);
        ds_map_replace(effects, SOAK_BLOOD, 0);
    }
}


//for things polling whether the character is on a medcabinet
onCabinet = place_meeting(x, y, HealingCabinet);

// Last x/y position for death cam if player is dead
player.lastKnownx=x;
player.lastKnowny=y;

// Here the view is set
if (player == global.myself)
{
    if (global.myself.class == CLASS_SNIPER and zoomed)
    {
        var relxmouse, relymouse;
        relxmouse = min(max(window_views_mouse_get_x()-view_xview[0], 0), view_wview);
        relymouse = min(max(window_views_mouse_get_y()-view_yview[0], 0), view_hview);
        
        view_xview[0] = x+relxmouse-view_wview[0];
        view_yview[0] = y+relymouse-view_hview[0];
    }
    else
    {
        view_xview[0] = x-view_wview[0]/2;
        view_yview[0] = y-view_hview[0]/2;
    }
}

realnumflames = numFlames * burnDuration / maxDuration;

// Decay deathmatch invulnerability if needed
if(deathmatch_invulnerable &gt; 0)
    deathmatch_invulnerable -= global.delta_factor * deathmatch_invuln_decay;
if(deathmatch_invulnerable &lt;= 0)
    deathmatch_invulnerable = 0;


</argument>
      </arguments>
    </action>
  </actions>
</event>
