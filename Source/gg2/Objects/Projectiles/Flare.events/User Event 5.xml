<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="OTHER" id="15">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">{
        if(exploded == true) {
            exit;
        } else {
            exploded = true;
        }
        instance_create(x,y,Explosion);
        playsound(x,y,ExplosionSnd);
        
        with (Character) {
            if (distance_to_object(other) &lt; other.blastRadius and !(team == other.team and id != other.ownerPlayer.object and place_meeting(x, y+1, Obstacle)))
            {
                var rdir, vectorfactor;
                rdir = point_direction(other.x,other.y,x,y);
                vectorfactor = point_distance(0, 0, power(sin(degtorad(rdir)), 2), power(cos(degtorad(rdir)), 2));
                motion_add(rdir, min(15, other.knockback-other.knockback*(distance_to_object(other)/other.blastRadius)) * vectorfactor);
                if(other.team != team or id==other.ownerPlayer.object) &amp;&amp; !ubered and hp &gt; 0
                {
                    bonus = 1;
                    if burnDuration &gt; 0 {
                        //if other.crit == 1 bonus = MINICRIT_FACTOR; ohhh this is bonus
                    }
                    var dmg;
                    dmg = other.explosionDamage*(1-(distance_to_object(other)/other.blastRadius));
                    //dmg *= (1+0*0.35*crit*bonus);
                    if id == other.ownerPlayer.object // self damage resistance
                        dmg *= 5/9;
                    
                    projectileCollision(other.ownerPlayer, id, dmg, other, 0);
                    {
                        if (burnDuration &lt; maxDuration) {
                            burnDuration += other.durationIncrease; 
                            burnDuration = min(burnDuration, maxDuration);
                        }
                        if (burnIntensity &lt; maxIntensity) {
                            burnIntensity += other.burnIncrease;
                            burnIntensity = min(burnIntensity, maxIntensity);
                        }
                        burnedBy = other.ownerPlayer;
                        afterburnSource = WEAPON_DETONATOR;
                        alarm[0] = decayDelay / global.delta_factor;
                    }

                    //if true hp -= other.explosionDamage*sqr((1-(distance_to_object(other)/other.blastRadius)))*(1+0*0.35)*1*bonus;
                    //if player == other.ownerPlayer hp-= 10*sqr((1-(distance_to_object(other)/other.blastRadius)))*(1+0*0.35)*1;
                    if (id == other.ownerPlayer.object and lastDamageDealer != -1 and lastDamageDealer != other.ownerPlayer and other.reflector == noone)
                    {
                        lastDamageSource = DAMAGE_SOURCE_FINISHED_OFF_GIB;
                    }
                    else 
                    {
                        if (lastDamageDealer != other.ownerPlayer and lastDamageDealer != player and other.reflector != lastDamageDealer)
                        {
                            secondToLastDamageDealer = lastDamageDealer;
                            alarm[4] = alarm[3];
                        }
                        if (other.ownerPlayer != id or (other.reflector != noone and other.ownerPlayer == id))
                            alarm[3] = ASSIST_TIME / global.delta_factor;
                        lastDamageDealer = other.ownerPlayer;
                        lastDamageSource = other.weapon;
                        //lastDamageCrit = other.crit;
                        if (id==other.ownerPlayer.object and other.reflector != noone)
                        {
                            lastDamageDealer = other.reflector;
                            lastDamageSource = WEAPON_REFLECTED_FLARE;
                        }
                    }
                    if (id==other.ownerPlayer.object)
                    {
                        moveStatus = 1;
                    }
                    else if (other.team == team)
                    {
                        moveStatus = 2;
                    }
                    else
                    {
                        moveStatus = 4;
                    }
                }
            }
        }

        
        with (Sentry){
            if (distance_to_object(other) &lt; other.blastRadius) &amp;&amp; (team != other.team) { 
            var thp;
            thp = other.explosionDamage*sqr((1-(distance_to_object(other)/other.blastRadius)))*1;
            if(currentWeapon &gt; -1 and humiliated = 0){if(currentWeapon.wrangled) thp /= 2}
            hp -= thp
            //hp -= other.explosionDamage*sqr((1-(distance_to_object(other)/other.blastRadius)))*other.crit;
            lastDamageDealer = other.ownerPlayer;
            lastDamageSource = other.weapon;
            //lastDamageCrit = 1;
            }   
        }    
         
         with (Generator){
            if (distance_to_object(other) &lt; other.blastRadius) &amp;&amp; (team != other.team) { 
                alarm[0] = regenerationBuffer / global.delta_factor;
                isShieldRegenerating = false;
                //allow overkill to be applied directly to the target
                var hitDamage;
                hitDamage = other.explosionDamage*sqr((1-(distance_to_object(other)/other.blastRadius)))*1;
                if (hitDamage &gt; shieldHp) {
                    hp -= hitDamage - shieldHp;
                    hp -= shieldHp * shieldResistance;
                    shieldHp = 0;
                } else {
                    hp -= hitDamage * shieldResistance;
                    shieldHp -= hitDamage;
                }
            }   
        }
        
        with (DeadGuy) {
            if (distance_to_object(other) &lt; other.blastRadius){
                motion_add(point_direction(other.x,other.y,x,y),10-10*(distance_to_object(other)/other.blastRadius));
            }
        }
         
        with (Gib) {
            if (distance_to_object(other) &lt; other.blastRadius){
                motion_add(point_direction(other.x,other.y,x,y),15-15*(distance_to_object(other)/other.blastRadius));
                rotspeed=random(151)-75;
            }
        }
        
        with(LooseSheet) {
            if (distance_to_object(other) &lt; other.blastRadius){
                motion_add(point_direction(other.x,other.y,x,y),10-10*(distance_to_object(other)/other.blastRadius));
            }
        }

        /*with(StickyMine) {
            if (distance_to_object(other) &lt; other.blastRadius) and (other.team == team){
                event_user(2);
            }
        }*/    
        
        instance_destroy();
}
</argument>
      </arguments>
    </action>
  </actions>
</event>
