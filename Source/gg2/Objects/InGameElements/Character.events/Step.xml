<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<event category="STEP" id="0">
  <actions>
    <action id="603" library="1">
      <!--action name: Code-->
      <kind>CODE</kind>
      <allowRelative>false</allowRelative>
      <question>false</question>
      <canApplyTo>true</canApplyTo>
      <actionType>CODE</actionType>
      <functionName/>
      <relative>false</relative>
      <not>false</not>
      <appliesTo>.self</appliesTo>
      <arguments>
        <argument kind="STRING">charSetSolids();

// Limit speed to prevent obstacle penetration
// (each dimension separately to avoid one vector affecting the other)
hspeed = min(abs(hspeed), 15) * sign(hspeed);
vspeed = min(abs(vspeed), 15) * sign(vspeed);

// Pretty sure this is for the healing ramp (crit heals)
// Done here instead of begin step to avoid code execution order mistakes
timeUnscathed = min(timeUnscathed+1*global.delta_factor, 10*30);

// Spinjumping emulation
if(global.run_virtual_ticks)
{
    if (sign(hspeed) &gt; 0) // See if we're "spinning", also mirror which side gets the boost so that the effect of spinjumping is perfectly symmetric
        _test = _last_xscale &gt; image_xscale;
    else
        _test = _last_xscale &lt; image_xscale;


    if (_test and !place_free(x+sign(hspeed), y)) // Rubbing wall and spinning
        spinjumping = true;
    else
        spinjumping = false;


    _last_xscale = image_xscale;
}

if(moveStatus == 1 or moveStatus == 2 or moveStatus == 4) // Make an anti-gravity for what our physics gravity should be (at 30fps)
    _gravity = 0.54;
else
    _gravity = 0.6;

if (spinjumping and
    place_free(x, y-_gravity) // validity check
    and (place_free(x, y+1) or vspeed &lt; 0) // In air, or jumping
   )
    applied_gravity -= _gravity;
else
    spinjumping = false; // prevent phantom spinjump dust

// The change in vspeed for gravity for DURATION of this frame (not the end of it!) is half the change there is by the end of it (see?)
// See gravity comments in Begin Step for rationale.
vspeed += applied_gravity*global.delta_factor/2;
if(vspeed &gt; 10)
    vspeed = 10;

// Run movement solver if necessary
yprevious = y;
xprevious = x;
y_previous = y;
x_previous = x;

var doHit;
doHit = !place_free(x+hspeed*global.delta_factor, y+vspeed*global.delta_factor);

if(doHit)
{
    characterHitObstacle();
}
else
{
    x += hspeed * global.delta_factor;
    y += vspeed * global.delta_factor;
}

// Fallback
if(place_free(x, y+1))
    vspeed += applied_gravity*global.delta_factor/2;
if(vspeed &gt; 10)
    vspeed = 10;
applied_gravity = 0;

// Handle dropdown platforms
if(!(keyState &amp; $02))
{
    with(DropdownPlatform)
    {
        if(other.y &lt; other.y_previous) continue;
        if(!place_meeting(x, y, other)) continue;
        if(place_meeting(x, y + (other.y - other.y_previous), other)) continue;
    
        with(other)
        {
            while(place_meeting(x, y, other) and place_free(x, y - 0.1))
                y -= 0.1;
            vspeed = 0;
        }
    }
}

x -= hspeed;
y -= vspeed;

// overheal from BassMakesPaste
if healer = -1 or !instance_exists(healer) {
   // todo: use global.delta_factor instead, its one line instead of 4
    if global.game_fps = 30 {
      overhealHp -= min(overhealHp, 0.1);
   } else if global.game_fps = 60 {
      overhealHp -= min(overhealHp, 0.05);
   }
} else if hp = maxHp {
    overhealed = true;
}

// abilities

if((keyState &amp; $10 &amp;&amp; currentWeapon.chainGun) || zoomed) {
    runPower = currentWeapon.revSlowdown;
    jumpStrength = currentWeapon.jumpSlowdown;
    //if (class != CLASS_HEAVY) jumpStrength = 0; // u want scouts jumping up n down?
} else {
    if (!zoomed) {
        runPower = baseRunPower;
        jumpStrength = baseJumpStrength;
    }
}

for(i=0; i&lt;2; i+=1) {
    if (abilityActive[i])
    {
        if (ability[i] == DASH)
        {
            jumpStrength = 0;
            if (moveStatus != 4) meter[i] -= 2; else if (moveStatus == 4) meter[i] -= 0.8; // lol, I am crazy for this
            //if (moveStatus != 4) meter[1] -= chargeDrain; else if (moveStatus == 4) meter[1] -= chargeDrain * 0.4;
            if (meter[i] &lt;= 0) abilityActive[i] = false;
            if (dashon) { // todo: figure out lastTurn
                if (moveStatus != 4) {
                    if (image_xscale == -1) {
                        hspeed -= 3;
                    } else if (image_xscale == 1) {
                        hspeed += 3;
                    }
                } else {
                    if (image_xscale == -1) {
                        hspeed -= 1.8 + (accel * 0.15);
                    } else if (image_xscale == 1) {
                        hspeed += 1.8 + (accel * 0.15);
                    }
                }
            }
        }
        if (weaponType[i] == BANNER) {
        // todo: add the whole library of abilities, oops copy pasting
            with(Character){
                if distance_to_point(other.x,other.y) &lt; 128 &amp;&amp; team == other.team {
                    currentWeapon.crit=1.15;
                    alarm[9] = 2;
                }
            }
        }
    } else {
      lastTurn = 0;
      jumpStrength = 8+(0.6/2);
    }
    if (rechargeAbility[i] == RECHARGE &amp;&amp; !abilityActive[i])
     if (meter[i] &lt; maxMeter[i]) meter[i] += rechargeRate * global.delta_factor;
}

// blurring

var canBlur1, canBlur2;
canBlur1 = (abilityActive[1] &amp;&amp; string_count("BLUR", abilityVisual[1]) != 0);
canBlur2 = (abilityActive[0] &amp;&amp; string_count("BLUR", abilityVisual[0]) != 0);

if (canBlur1 || canBlur2) {
    if (blur == -1) {
        blur =instance_create(x,y,RadioBlur);
        blur.owner = id;
    }
} else {
    if (blur != -1) {
        with(blur) {
            image_alpha -= 0.1 / global.delta_factor;
            if image_alpha &lt;= 0.01 {
                instance_destroy();
                other.blur = -1;
            }
        }
    }
}
/* commented cause this i statement is not working too good, fix later!
for(i=0; i&lt;2; i+=1) {
    canBlur = (abilityActive[i] &amp;&amp; string_count("BLUR", abilityVisual[i]) != 0);
    if (canBlur) {
        if (blur == -1) {
            blur =instance_create(x,y,RadioBlur);
            blur.owner = id;
        }
    } else {
        if (blur != -1) {
            with(blur) {
                image_alpha -= 0.1 / global.delta_factor;
                if image_alpha &lt;= 0.01 {
                    instance_destroy();
                    other.blur = -1;
                }
            }
        }
    }
}*/

charUnsetSolids();
</argument>
      </arguments>
    </action>
  </actions>
</event>
